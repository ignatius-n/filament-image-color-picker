// resources/js/components/image-color-picker.js
function canvasColorPicker({
  image,
  state
}) {
  function loadImage(src) {
    const img = new Image();
    img.src = src;
    return new Promise((resolve, reject) => {
      img.complete ? resolve(img) : img.addEventListener("load", () => resolve(img));
      img.addEventListener("error", reject);
    });
  }
  return {
    /**
     * @type {HTMLCanvasElement|null}
     */
    canvas: null,
    previewColor: null,
    selectedColor: state,
    init() {
      const canvas = this.$refs.canvas;
      loadImage(image).then((img) => {
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
      });
      this.canvas = canvas;
    },
    onClick(e) {
      this.selectColor(e);
      this.selectedColor = this.previewColor;
    },
    selectColor(e) {
      const {
        x,
        y
      } = this.getRelativeCoordinates(e.clientX, e.clientY);
      const ctx = this.canvas.getContext("2d");
      const {
        data
      } = ctx.getImageData(x, y, 1, 1);
      this.previewColor = this.rgbToHex(data[0], data[1], data[2]);
    },
    /**
     * @param {Number} eventX
     * @param {Number} eventY
     */
    getRelativeCoordinates(eventX, eventY) {
      const canvas = this.canvas;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (eventX - rect.left) * scaleX;
      const y = (eventY - rect.top) * scaleY;
      return {
        x,
        y
      };
    },
    rgbToHex(r, g, b) {
      const hex = [r, g, b].map((number) => number.toString(16).padStart(2, "0").toUpperCase()).join("");
      return `#${hex}`;
    }
  };
}
export {
  canvasColorPicker as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tcG9uZW50cy9pbWFnZS1jb2xvci1waWNrZXIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FudmFzQ29sb3JQaWNrZXIoe1xuICAgIGltYWdlLFxuICAgIHN0YXRlXG59KSB7XG5cbiAgICBmdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjKSB7XG5cbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zcmMgPSBzcmM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGltZy5jb21wbGV0ZSA/IHJlc29sdmUoaW1nKSA6IGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4gcmVzb2x2ZShpbWcpKVxuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGNhbnZhczogbnVsbCxcblxuICAgICAgICBwcmV2aWV3Q29sb3I6IG51bGwsXG5cbiAgICAgICAgc2VsZWN0ZWRDb2xvcjogc3RhdGUsXG5cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLmNhbnZhcztcblxuXG4gICAgICAgICAgICBsb2FkSW1hZ2UoaW1hZ2UpLnRoZW4oKGltZykgPT4ge1xuXG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Q29sb3IoZSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDb2xvciA9IHRoaXMucHJldmlld0NvbG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdENvbG9yKGUpIHtcblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IHRoaXMuZ2V0UmVsYXRpdmVDb29yZGluYXRlcyhlLmNsaWVudFgsIGUuY2xpZW50WSlcblxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIDEsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLnByZXZpZXdDb2xvciA9IHRoaXMucmdiVG9IZXgoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50WFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnRZXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZWxhdGl2ZUNvb3JkaW5hdGVzKGV2ZW50WCwgZXZlbnRZKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gY2FudmFzLndpZHRoIC8gcmVjdC53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IGNhbnZhcy5oZWlnaHQgLyByZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgY29uc3QgeCA9IChldmVudFggLSByZWN0LmxlZnQpICogc2NhbGVYO1xuICAgICAgICAgICAgY29uc3QgeSA9IChldmVudFkgLSByZWN0LnRvcCkgKiBzY2FsZVk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmdiVG9IZXgociwgZywgYikge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gW3IsIGcsIGJdLm1hcCgobnVtYmVyKSA9PiBudW1iZXIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykudG9VcHBlckNhc2UoKSkuam9pbignJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBgIyR7aGV4fWA7XG4gICAgICAgIH1cbiAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjtBQUNlLFNBQVIsa0JBQW1DO0FBQUEsRUFDdEM7QUFBQSxFQUNBO0FBQ0osR0FBRztBQUVDLFdBQVMsVUFBVSxLQUFLO0FBRXBCLFVBQU0sTUFBTSxJQUFJLE1BQU07QUFDdEIsUUFBSSxNQUFNO0FBRVYsV0FBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDcEMsVUFBSSxXQUFXLFFBQVEsR0FBRyxJQUFJLElBQUksaUJBQWlCLFFBQVEsTUFBTSxRQUFRLEdBQUcsQ0FBQztBQUM3RSxVQUFJLGlCQUFpQixTQUFTLE1BQU07QUFBQSxJQUN4QyxDQUFDO0FBQUEsRUFDTDtBQUVBLFNBQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUtILFFBQVE7QUFBQSxJQUVSLGNBQWM7QUFBQSxJQUVkLGVBQWU7QUFBQSxJQUVmLE9BQU87QUFJSCxZQUFNLFNBQVMsS0FBSyxNQUFNO0FBRzFCLGdCQUFVLEtBQUssRUFBRSxLQUFLLENBQUMsUUFBUTtBQUUzQixlQUFPLFFBQVEsSUFBSTtBQUNuQixlQUFPLFNBQVMsSUFBSTtBQUVwQixjQUFNLE1BQU0sT0FBTyxXQUFXLElBQUk7QUFFbEMsWUFBSSxVQUFVLEtBQUssR0FBRyxDQUFDO0FBQUEsTUFDM0IsQ0FBQztBQUVELFdBQUssU0FBUztBQUFBLElBQ2xCO0FBQUEsSUFFQSxRQUFRLEdBQUc7QUFDUCxXQUFLLFlBQVksQ0FBQztBQUVsQixXQUFLLGdCQUFnQixLQUFLO0FBQUEsSUFDOUI7QUFBQSxJQUVBLFlBQVksR0FBRztBQUVYLFlBQU07QUFBQSxRQUNGO0FBQUEsUUFDQTtBQUFBLE1BQ0osSUFBSSxLQUFLLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxPQUFPO0FBRXBELFlBQU0sTUFBTSxLQUFLLE9BQU8sV0FBVyxJQUFJO0FBRXZDLFlBQU07QUFBQSxRQUNGO0FBQUEsTUFDSixJQUFJLElBQUksYUFBYSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBRS9CLFdBQUssZUFBZSxLQUFLLFNBQVMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFBQSxJQUUvRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNQSx1QkFBdUIsUUFBUSxRQUFRO0FBRW5DLFlBQU0sU0FBUyxLQUFLO0FBRXBCLFlBQU0sT0FBTyxPQUFPLHNCQUFzQjtBQUMxQyxZQUFNLFNBQVMsT0FBTyxRQUFRLEtBQUs7QUFDbkMsWUFBTSxTQUFTLE9BQU8sU0FBUyxLQUFLO0FBRXBDLFlBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxZQUFNLEtBQUssU0FBUyxLQUFLLE9BQU87QUFFaEMsYUFBTztBQUFBLFFBQ0g7QUFBQSxRQUNBO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxJQUVBLFNBQVMsR0FBRyxHQUFHLEdBQUc7QUFDZCxZQUFNLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxXQUFXLE9BQU8sU0FBUyxFQUFFLEVBQUUsU0FBUyxHQUFHLEdBQUcsRUFBRSxZQUFZLENBQUMsRUFBRSxLQUFLLEVBQUU7QUFFakcsYUFBTyxJQUFJLEdBQUc7QUFBQSxJQUNsQjtBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFtdCn0K
